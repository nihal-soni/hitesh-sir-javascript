avaScript Execution Context (Step-by-Step Explanation)
‚úÖ What is Execution Context?

Execution Context (EC) is the environment in which JavaScript code is executed. It determines:

1. How JavaScript code is executed
2. How variables and functions are stored in memory
3. How scope and closures work



üéØ Types of Execution Contexts in JavaScript
There are three types of execution contexts:

1Ô∏è‚É£ Global Execution Context (GEC)

Created when JavaScript first runs.
this in the global execution context refers to:
window object in browsers
global object in Node.js

2Ô∏è‚É£ Function Execution Context (FEC)

Created whenever a function is called.
Each function has its own execution context.
Can have nested execution contexts (functions inside functions).


3Ô∏è‚É£ Eval Execution Context
Created when eval() is used (rarely used in modern JavaScript).




üî• How JavaScript Code Executes (Behind the Scenes)
Every JavaScript program runs in two phases:

üî∑ 1Ô∏è‚É£ Creation Phase (Memory Allocation)

The JavaScript engine allocates memory for variables & functions.
Variables are initialized with undefined.
Functions are stored in memory as a whole.

üî∂ 2Ô∏è‚É£ Execution Phase (Code Execution)

Variables get assigned values.
Functions get executed.



console.log(x);  // ‚ùì What will this print?
var x = 5;
console.log(x);  // 5

function greet() {
  console.log("Hello, Nihal!");
}
greet();
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Step 1: Creation Phase (Memory Allocation) 

Global Execution Context (GEC) is created.

var x is assigned undefined in memory.

greet() function is stored in memory.

Step 2: Execution Phase

console.log(x); ‚Üí Prints undefined (because x is hoisted but not assigned yet).

x = 5; ‚Üí Now x gets the value 5.

console.log(x); ‚Üí Prints 5.

greet(); ‚Üí Calls the function, printing "Hello, Nihal!".



üéØ Example: Function Execution Context

function outer() {
  var a = 10;
  function inner() {
    var b = 20;
    console.log(a + b);
  }
  inner();
}
outer();

üîÑ Step-by-Step Execution
Global Execution Context (GEC) is created.
outer() function is stored in memory.
outer() is called ‚Üí New Function Execution Context (FEC) is created.
a = 10 is assigned inside outer().
inner() is called ‚Üí New Function Execution Context (FEC) is created for inner().
b = 20 is assigned inside inner().
console.log(a + b); ‚Üí Prints 30.
Execution Context for inner() is destroyed.
Execution Context for outer() is destroyed.
üî• Call Stack (Execution Context Stack)
JavaScript uses a Call Stack to manage execution contexts.

üìå Example: Understanding the Call Stack

function first() {
  console.log("First");
  second();
}

function second() {
  console.log("Second");
  third();
}

function third() {
  console.log("Third");
}

first();

Step-by-Step Call Stack Execution
1Ô∏è‚É£ Global Execution Context (GEC) is created.
2Ô∏è‚É£ first() is called ‚Üí Push first() onto the stack.
3Ô∏è‚É£ console.log("First"); ‚Üí Prints "First".
4Ô∏è‚É£ second() is called ‚Üí Push second() onto the stack.
5Ô∏è‚É£ console.log("Second"); ‚Üí Prints "Second".
6Ô∏è‚É£ third() is called ‚Üí Push third() onto the stack.
7Ô∏è‚É£ console.log("Third"); ‚Üí Prints "Third".
8Ô∏è‚É£ third() completes ‚Üí Removed from the stack.
9Ô∏è‚É£ second() completes ‚Üí Removed from the stack.
üîü first() completes ‚Üí Removed from the stack.

üöÄ Key Takeaways
‚úÖ Execution Context is the environment where JavaScript code runs.
‚úÖ Global Execution Context (GEC) is created first.
‚úÖ Each function call creates a new Function Execution Context (FEC).
‚úÖ JavaScript runs in two phases: Memory Allocation & Execution.
‚úÖ Call Stack manages execution contexts.

üî• Interview Questions on Execution Context

‚ùì Q1: What are the different types of Execution Contexts in JavaScript?

‚úÖ Answer:

Global Execution Context (GEC)
Function Execution Context (FEC)
Eval Execution Context (rarely used)

‚ùì Q2: What will be the output of the following code?

console.log(a);
var a = 10;
console.log(a);
‚úÖ Answer:
undefined
10

Explanation:

Memory Phase: var a is hoisted and initialized as undefined.
Execution Phase: First console.log(a) prints undefined, then a = 10, and second console.log(a) prints 10.

‚ùì Q3: Explain the role of the Call Stack in JavaScript.
‚úÖ Answer:

The Call Stack keeps track of function calls.
Each function call adds an execution context to the stack.
When a function completes, its execution context is removed from the stack.
